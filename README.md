# The Case for Non-linguistic Approach to Teaching Engineering Thinking

Software engineering is a multifaceted discipline. Mastering it requires memorizing a lot of factual information as well as learning a particular set of skills that enable the learner to tackle complex engineering tasks in a more efficient manner. It also requires the knowledge of at least one programming language. This makes teaching software engineering efficiently difficult. The need for new ways to train programmers can be felt in many companies and industries. Beginning with commercial software being repurposed for education[^1], to industry professionals developing education courses of their own, trying to fill a gap in traditional computer science education[^2] [^3]. The traditional way of teaching programming (and by extension - engineering) to students heavily relies on delivering information in the form of lectures and via textbooks. Lectures are becoming less and less effective[^petersen] when it comes to teaching programming, and there are methods of doing it using software solutions which take into account how the human brain processes code. This text will attempt to list several characteristics of software-based learning that could be used to improve the teaching process in computer science. It will also provide a summary of various methods of using visual information to improve the programming learning experience[^4]. Finally, it will provide several concrete examples of how software enables students to learn the “spirit of engineering and problem solving”[^5].

## Reliance on “content delivery”

Traditionally college/university-level engineering courses are taught in the form of lectures, where teachers are required by the curriculum to cover a certain amount of content to prepare their students for subsequent courses or examinations. Even though lectures can make up only part of a course (with other parts being dedicated to hands-on practice in the form of laboratory work or seminars where students drive the learning process), it is a significant part that students tend to pay the most attention to. As such, lectures become the core of each course and shape the students’ impressions of the subject. This often has drastic consequences for students’ success in later courses that rely on material from previous courses, even more so in cases where students are expected to have mastered certain skills during a course[^olsson].

Software engineering as a discipline requires vast knowledge of specialized tools and concepts. Thus, the learning process is very intensive and spans across multiple courses covering programming languages, hardware, software design patterns, mathematical algorithms etc. Students are expected to absorb all that knowledge and be able to apply it to solving complex problems, often under stress. 

It has been observed that people struggle when they are required to memorize a lot of new information, this phenomenon is explained by the working memory theory[^mayer]. This goes in contrast with what students are expected to memorize during a single lecture. This negative effect is amplified when teaching subjects like programming, with the categories of information that has to be memorized changing constantly: lecture material often mixes language-specific information (keywords, syntactical rules, ready solutions), mathematical basis for a given solution (algorithm theory), hardware-specific limitations (computer memory management) etc. 

Surveys conducted among software engineers consistently show that in most cases the average time spent writing code hovers slightly above 40% of their total working time[^ds19][^tl19]. Those estimated periods reported as “working on code” often include designing the program, doing research, “debugging” (resolving issues with existing code), reading code written by someone else, and other tasks not directly related to typing the program into a text file. So, the time spent using programming languages makes up less than 40% of what a software engineer does when working. 

Students are expected to develop certain ideas, concepts, and mental skills that link together disjointed chunks of knowledge into a coherent whole that forms a clear picture of how to solve programming problems. As this paper argues, that part of the learning process is the most important one and it is that part that determines how successful a student will be while solving programming/engineering tasks. Those ideas and skills cannot be learned by listening to a lecture or by reading a book, though they are learned about, which has its own value. Programming can only be learned by solving problems specifically designed to develop these kinds of skills. 

To reiterate, memorization requires development of multiple neural links in the corresponding neural networks, ergo - active interaction with a given piece of information and deliberate dwelling on the result of that interaction are needed (see fig. 1), and this is hard to achieve in a lecture environment. 

The process of learning is not simply about transferring knowledge from teacher to student. In fact, knowledge does not have to be “existing in an objective manner” for subsequent transmission, it can also be “built in a constructive manner by the learner"[^albano]. Therefore, lecture is a process of deconstructing knowledge by the teacher, negotiating between teacher and learner, and subsequently reconstructing it by the learner[^albano]. 

Designing and writing software is one of the most complex problems students can be tasked with. Software itself is often on the leading edge of any given industry’s advancement. It follows that software engineering/programming courses should be on the bleeding edge of education. In actuality, the opposite is true. High-profile courses like [Harvard University’s CS50 program](https://cs50.harvard.edu/college/2021/fall/syllabus/), while claiming to be designed “with the aims of making the content of the course more widely available and contributing to public understanding of innovative learning”, do not go too far from the traditional lecture form in their attempts to innovate learning, only supplementing information delivered during lectures with various visualization techniques, and only sporadically. The author of this paper argues that simple visualizations, while helpful at facilitating memorization of new information via appealing to the temporal and spatial perception centers of the brain by illustrating relations between objects in space and time, do not illustrate the relations between different concepts presented to students from one lecture to the next, leaving it up to students to infer those connections from the material given to them. 

## Text and meta-text

Recent studies have shown that the parts of the human brain that are linked to code comprehension do not overlap in a significant way with the parts of the brain linked to language processing (see fig. 2)[^liu][^ivanova].

“One possible explanation for low overlap between the perisylvian fronto-temporal language network and code, is that the language system is evolutionarily predisposed to support natural language processing in particular, and is therefore not generalizable even to similar domains, like computer code and formal logic”[^liu]. Learning programming as an activity is not based solely on learning a programming language. It is primarily about solving logical tasks and then applying a programming language to recording resulting solutions in text form for subsequent reuse. However, it should be noted that “despite lack of direct overlap, lateralization patterns of language and coding were highly correlated across individuals, that is those individuals with highly left-lateralized responses to sentences also showed highly left-lateralized responses to code. This intriguing observation suggests that the relationship between code and language may be ontogenetic as well as phylogenetic. It is hard to imagine how code in its current form could have been invented in the absence of language”[^liu]. This is partially confirmed by an earlier study[^siegmund]. 

Similar findings have been made by researchers from other fields (psychology, for example), who claim that the process of thinking itself does not directly correlate with speech, only overlapping with it in some areas[^vygotsky]. Furthermore, instrumental thinking - the ability to understand mechanical joints and devise mechanical solutions for problems that are mechanical in their nature - is linked to concepts and speech as a function of the brain to a much lesser degree i.e., actions become subjectively comprehended before being manifested in speech[^vygotsky]. The primary function of instrumental thinking does not lie in transferring of knowledge but in applying accumulated knowledge to problem solving[^kornilov]. 

There’s empirical evidence showing that information is not encoded by the brain in any symbolic form (as text, as images etc.), instead it is stored and operated on as a series of abstractions (through the process of ideation)[^albano]. Which could mean that while performing engineering tasks a software engineer’s brain keeps switching between its distinct parts passing information from one part to another, having to decode that information into abstract forms at each stage. Additionally, when text/speech is used in an education environment, three of its functions must be considered. First, the writer/speaker uses language to communicate thoughts and ideas. Second, the writer/speaker’s intention is to be understood. Third, “beyond the linguistic code, communication entails a special structure of embedded intentions (the intention that others understand one’s intentions) and is based on cooperative principles by which interlocutors work together toward understanding each other”[^liszkowski]. This last function can never be guaranteed to apply when communicating through text/speech, because when the source of information encodes ideas into natural language the ideation process of the person(s) reading that text or hearing that sentence is intruded upon. 

Text is the primary means of learning how to program for most beginners. As shown above, the process of designing programs involves instrumental (technical, engineering) thinking, it follows then that learning programming from textbooks is most useful when learning a programming language, and by that point students should already have a good understanding of the kind of problems they would use that language for and have developed thought patterns for solving them efficiently. In reality, this learning process is reversed, students are first explained these abstract concepts in text form in addition to using code snippets to illustrate those concepts, then the code itself is explained - its grammatical and syntactical rules - to keep up with the process of learning new concepts, and this cycle is repeated over and over. This is easily confirmed by looking at the approach many authors take in published programming textbooks aimed at beginners. They tend to start with general concepts of how computers process data (registers/variables, memory, and CPU), then transition to explaining how their language of choice can be used to manipulate data (variables and simple data structures), then explain simple constructs (loops, conditional statements, modules) etc. This implies that people cannot learn to think like programmers until they learn how to program in at least one language. This method of teaching programming should not be the primary or even the widely accepted way, especially in an environment of a guided education process. 

To summarize, verbal or textual explanations of complex engineering/programming concepts must go through several brain centers (working memory, language processing, multiple-demand network[^ivanova]) before they are fully assimilated and can be memorized, which takes time and a lot of repetition to develop corresponding neural networks in the brain, and puts an extra burden on the receiver of such information. In addition to that, received information needs to be easy to understand for each individual learner. Satisfying all these conditions while reading a lecture is difficult, to say the least. Learners must focus on several tasks that are processed by the brain differently (learning a programming language, code comprehension, logical problems, mathematical problems etc.), employing multiple areas of the brain simultaneously (although these areas sometimes overlap), which is very demanding in and of itself.

Traditional approaches to learning (and teaching) programming revolve around reading copious amounts of text, which mostly teaches how to read other forms of text (code). While there is intrinsic value in reading code written by experts, reading explanations of that code is much less effective than trying to reason about the structure/function of a program and various features of a programming language and is of little value for the reasons listed above. A question then arises: is there an alternative more efficient way to teach the aforementioned “spirit of programming”, the abstract concepts of “programming” as a mental model? In other words, can students be taught to think like software engineers before learning a programming language or in some cases - before becoming fully fledged software engineers? 

## Computational thinking

Before discussing ways to stimulate the process of inferring specific concepts and ideas it needs to be established how exactly a programmer’s (and by extension - engineer's) way of thinking is different from the way of thinking of specialists from other fields. The term “instrumental thinking” borrowed from psychology was mentioned above several times. And while it applies to programming it is not directly linked to it because it had been in use before programming as activity fully emerged. To narrow the scope of this part down a new term must be introduced. 

Computational thinking “is the thought process involved in formulating a problem and expressing its solution(s) in such a way that a computer—human or machine—can effectively carry out”[^wing14]. In broader terms, this kind of thinking process can be described as “reformulating a seemingly difficult problem into one we know how to solve, perhaps by reduction, embedding, transformation, or simulation”[^wing14]. Computational thinking as a concept does not describe a new kind of thinking process in a neuro-biological sense, it is a specialized term substituting “instrumental thinking” that implies understanding of objective processes specific to the problem at hand (see above). This could indicate the existence of the same relation between this type of thinking and speech as in the case of instrumental thinking. However, it is stated that “computational thinking is conceptualizing, *not programming*. It describes a way of thinking at multiple levels of abstraction, not only the ability to program”[^wing06] \[emphasis added\]. Thus, programming is a subset of computational thinking, since it is stated that computational thinking involves solution expression, at the same time contrasting it with programming. For the purposes of this paper, it is enough to consider that the process of producing a solution to an engineering problem is the same as doing so for a programming problem. 

That has other implications as well. Firstly, that “programming” as an activity is separated into several distinct stages: formulating a problem, expressing a solution (in mathematical notation, programming language etc.), executing, evaluating - some or all of which go under the aegis of computational thinking - “[computational thinking] complements and combines mathematical and engineering thinking”[^lamprou]. Secondly, expressing a solution i.e., recording a set of steps using natural or formal languages itself requires a specific form of thinking, because distinct parts of the brain must be activated to enable this process - logic, reasoning, language etc. - all of which must be developed reasonably well to efficiently process incoming data and produce solutions. In this paper’s author’s opinion this is what distinguishes programming from other disciplines. A programmer/software engineer has to master multiple disciplines and train various parts of his brain before he can be confident in his abilities. 

Consider these three primary forms of activity programmers routinely engage in: devising a solution to a problem; expressing that solution in code; evaluating and tweaking the solution. Each of these activities requires different strategies, concepts, and forms of knowledge. This would mean that learning to do each of them would require different approaches as well. The nature of the process behind the second activity is more easily understood since it involves mapping ready instructions to a specific language’s grammatical and syntactic rules. The thought processes behind the remaining two activities are not as easily defined. But regardless of the nature of the thought processes involved in the activities listed above, what’s important to point out is, it is not hands-on/empirical experience that is responsible for developing neural networks in the brain but the nature of the experienced activity, because the brain develops new pathways in response to acquiring new information [^oby]. Therefore, the chosen learning strategy bears the most importance in regards to effectiveness of learning processes. 

## Non-linguistic learning

While this paper’s goal is to show that non-linguistic learning in the context of computational thinking is possible, it remains to be proven whether non-linguistic forms of learning are more efficient than traditional forms. However, there are several important benefits of using non-linguistic learning which could be leveraged for a more efficient learning process overall regardless of the medium: language agnostic learning solutions, conformity with the multimedia principle of delivering information, cognitive load theory aware methods of teaching, reflection-based learning, reactive learning environments, inference-inductive activities. This is by no means an exhaustive list and these characteristics are not exclusive or inherent to non-linguistic learning methods but all of them can be tapped into using non-linguistic forms of learning with the help of proper tools and methods to enhance the learning process. 

Before discussing concrete examples of such tools, methods those tools employ etc. it is important to look at the properties listed above more closely. Using non-linguistic methods of transferring information has two immediate consequences. First, students are not limited by the need to have prior knowledge of a specialized language or notation, or the need to dedicate time to getting acquainted with a notation/language. Second, it could also be beneficial to transfer information without the use of text to skip the decoding step the brain would have to make when encountering text, instead planting ideas into the respective areas of the brain directly (similarly to how code does it, appealing to the multiple-demand system, see above). 

Working memory of the brain is limited in how much information it can hold onto at any one time. That amount can be looked at as “cognitive load” or “the cognitive effort (or amount of information processing) required by a person to perform \[a\] task” [^shibli]. It can be associated with a specific topic, the way information or tasks are presented to a learner, or the work put into creating a permanent store of knowledge (a schema). Specifically, “extraneous overload occurs when essential cognitive processing (required to understand the essential material in a multimedia message) and extraneous cognitive processing (required to process extraneous material or to overcome confusing layout in a multimedia message) exceed the learner’s cognitive capacity” [^mayer]. 

Non-linguistic forms of learning reduce the amount of extraneous information students must sift through while performing a learning task, which enables them to focus on the information relevant to learning, reducing cognitive load. 

Cognitive theory of multimedia learning (CTML) assumes that “the working memory processes verbalized and visual pictorial information in two separate channels” [^thees]. To leverage that inherent characteristic of working memory it is advised to use multimedia instructions to “reduce extraneous processing, manage essential processing, and \[foster\] generative processing”, or simply put - to “maximize the amount of available mental resources” [^thees]. It has been empirically shown that “people learn more deeply from a multimedia message when extraneous material is excluded rather than included” [^mayer]. Tools that enable non-linguistic forms of learning intrinsically conform to the multimedia principle, because “people learn more deeply from graphics and narration than from graphics, narration, and on-screen text” [^mayer]. Such tools limit the use of text and guide the learner’s focus by other means (for example, communicating essential information and relations about information via spatial arrangement) [^mccrudden]. 

Reflection is another powerful teaching tool. “When learners reflect, the otherwise implicit knowledge becomes digested through active interpretation, questioning, and exploration” [^villareale]. It is worth pointing out that reflection is widely used in modern-day programming for incrementally improving software features (analysis) and diagnosing problems in software products (debugging). It is a crucial skill for a software developer. And yet very little time is dedicated to teaching core concepts of debugging/analysis/profiling to beginners. Purpose-built non-linguistic learning tools could and should incorporate reflection into the learning process, “it is essential to increase learning outcomes and the learner’s awareness of their own learning” [^villareale]. 

Reactivity is omnipresent in computer games because it is one of the primary tools designers and programmers use to guide the player during the gaming process. Consider this simple example: playing a tabletop version of Solitaire for the first time. If the player does not have a good grasp of the game’s rules and makes a mistake (places a card in an invalid position) he will not be aware of his mistake unless someone else points it out. Now replace the tabletop version with a software version of the same game. The rules did not change, now if the player makes the same mistake, the game can react to it by notifying the player of that. In fact, developers can have checks for all possible invalid game states in place to prevent players from making any kind of mistakes. This is a great teaching tool because it does not require prior experience with the game from players. The game can be successfully completed by trial and error, simultaneously teaching players its rules. This principle could be utilized in educational software to teach certain aspects without requiring learners to read large volumes of text. 

Inference is one of the primary functions by which humans receive information, especially in cases where “sensory data are scanty or ambiguous, or incongruities occur in perceptual situation” [^vernon]:. Naturally, inference plays a major part in the process of non-linguistic learning. “Human communication is an inferential process that requires sophisticated cognitive skills” [^liszkowski]. It is characterized by its “intentionality and cooperative processes, not by language alone” [^liszkowski]. Educators intuitively rely on inference in students for drawing correct conclusions based on incomplete sets of data, since their curriculum limits what information and how much of it to include into the learning material. 

A structure of such intentions embedded into communication “makes it possible to infer meanings beyond explicitly conveyed language” [^liszkowski]. There is a plethora of research data supporting the idea of the effectiveness of visual “displays” in promoting learning. Cognitive processing has several forms (Mayer’s “select-organize-integrate” model, see fig. 3) that can be leveraged “to afford different kinds of inferences” by using visual displays [^mccrudden]. 

In this context selection refers to focusing on certain information in an instruction. It can be promoted by driving attention to one part of a message and omitting non-critical information. Organization refers to inferring relations between pieces of information. It is especially important for memorization since associations between new data and prior knowledge “facilitates retrieval from long-term memory”, this process is guided by integration [^mccrudden].

## Examples

This paper will describe three software products that conform to the characteristics described above, and promote non-linguistic learning very effectively. It is worth noting that all these examples were not built as dedicated educational software, they are software puzzle games, which is interesting in itself: the best work on promotion of computational thinking using innovative approaches is being done outside of education, while the opposite would be expected.

###### [Baba is You](https://hempuli.com/baba/) (2019)

The first example is a rather unique puzzle game in which puzzles are solved using linguistics. The rules of the game are not explained through textual descriptions, instead they are presented for each puzzle as short phrases that define the relations between objects on the screen, and are a part of the playing space (see fig. 4).

“Baba is you” indicates to the user that an entity named Baba is under his control, it is the player’s means of interacting with the world. “Flag is win” hints at the winning condition (get Baba to the flag to win), “wall is stop” informs the player that the playable character cannot go through wall tiles. “Rock is push” indicates to the player that tiles that look like rocks can be pushed away. 

But it is not until the second puzzle that the players realize, there is a lot more to the problems presented by the game to them (see fig. 5).

Now Baba is surrounded by walls. The interesting part is: the phrase “wall is stop” is placed right next to the player’s character. This is a subtle hint at how subsequent puzzles are designed. Baba can interact with everything on the screen including phrases that describe the rules. And those phrases can be changed by using Baba to push parts of them away. Altering the phrase in such a way will change the rules governing the current puzzle. For example, pushing either “wall”, “is” or “stop” in that phrase will make all the walls on the screen non-corporeal allowing Baba to reach the flag on the other side of the wall. 

What’s even more interesting is the alternative solution to this puzzle. Since there is no limitation on where you can push different elements within the confines of the screen, it is possible to push “win” in order to form the phrase “wall is win” (see fig. 6). 

This will expectedly allow the level to be completed by placing Baba on top of any wall tile. Players are taught another important skill in this instance: thinking “outside the box”, which is a particularly important skill for a programmer to have, because every problem in programming has multiple viable solutions. Some solutions are more effective, while other solutions cheaper etc. but all of them are valid. The way Baba is You teaches this and other aspects of computational thinking without saying as much as an entire sentence, is ingenious.

###### [SpaceChem](https://www.zachtronics.com/spacechem/) (2011)

Next example is a puzzle game that employs elements of systemic design to solve problems that it poses before players. The game’s developers describe it as follows, “a design-based puzzle game is a puzzle game where solutions take the form of a design”5. To elaborate on that definition, traditional puzzles have only a single solution, so the goal is to figure out that solution. SpaceChem’s puzzles are set up in ways that do not support just one possible state but instead require the player to create a particular design by any means. This leads to each puzzle having multiple viable solutions.  

SpaceChem uses several elements to solidify its approach to teaching players how to solve its puzzles. Emergent tools, which refers to the ability to combine the game’s primitive components in a multitude of ways, creating unique solutions. Precise goals, the focus of each problem is on achieving a certain goal (create and transport N molecules of water, for example), not on how it is achieved. Canvases and constraints, this supports the idea that each design inherently has a set of constraints it is developed within, those constraints drive the design and motivate the engineer/designer to be creative with his/her solutions. 

Puzzles are composed of several main sections. The center of the screen has a working area with input and output sections to the sides. At the bottom of the screen is a table of working symbols that are used to build the solution (see fig. 7). 

The goal is to use elements from the input to construct whatever is required at the output. This is done by building one or several conveyors that loop around the working area taking input elements, combining them if needed and transporting them to the output. Below is an example of a completed puzzle (see fig. 8).  

Completing a puzzle will result in a statistical screen (see fig. 9).  

Histograms on the completion screen are generated using data from the player’s most recent solution, and data from the player’s friends who also attempted the puzzle. These histograms compare performance of all players, thus using social links to encourage evaluation of the efficiency of one’s own solution. The player is informed of the fact that there are more efficient ways of solving the problem, and is shown the actual numbers behind the most efficient solution. This motivates the player to try to solve the puzzle again to improve the design, reevaluate one’s own work and iterate on it to perfect the outcome. That is one of the most important principles an engineer can learn: iterating on one’s design in order to improve it, ever so slightly. SpaceChem leverages the social element to motivate players by example from their peers, which is possible thanks to available network infrastructures that enable developers to connect players with one another. The learner gradually builds up professional intuition, and is subtly taught the importance of empirical validation. 

###### [SHENZHEN I/O](https://www.zachtronics.com/shenzhen-io/) (2016)

The last example is the most elaborate puzzle game of the ones presented in this paper. It was developed by the same company that made SpaceChem. It has several categories of tools for solving its puzzles. The first category consists of modules with input and output in different configurations. Input and output wires connect to the respective ports on a chip. The player’s task is to program the chip using a simple procedural programming language (see fig. 10).

The goal of each puzzle is displayed in the form of a two-dimensional graph that describes a discrete function in a special window for information. This window also has buttons for checking the connections of all the wires in the puzzle, as well as a profiler - a utility for identifying the program’s performance at runtime (i.e., in real time while the program is running, see fig. 11).

An example of a problem that the player would have to solve could be, increase the output signal’s power by two for a given signal input strength and pattern. The player then must use the proper module(s) and write a correct program for each module to solve the puzzle in order to progress. 

While SHENZHEN I/O is a commercial product that was not made for educational institutions, or even for professional programmers, it perfectly encapsulates the software engineering experience. It teaches the basics of a simple programming language in a controlled environment guiding the learner to gradually build up knowledge. As the learner accumulates experience, in-game puzzles become more complicated requiring more sophisticated solutions. The learner has several advanced tools at his disposal, mastering which gives him invaluable knowledge of the process of evaluating software (debugging and profiling). Each solution is compared to other solutions to give the learner extra motivation to reevaluate his work and improve it. The nature of SHENZHEN I/O‘s tools also makes it possible to go beyond puzzles that are present in the game itself. It allows users to construct a multitude of devices for many different purposes using any combinations of modules and the game’s programming language (for example, [Conway’s Game of Life](https://www.youtube.com/watch?v=BGLWE6S68b0)).

All of the examples above share several traits that are invaluable for computer science education (and in most cases - outside of it as well). Games are inherently suited for use in education. All higher animals engage in some form of games for learning purposes in the early stages of their lives [^huizinga]. Experience gained during such activity, including examples highlighted in this paper, is applicable in real life. However, the same cannot be said about most computer gaming software. Games are well suited for learning in context of specific forms of knowledge, where games fare much better than other forms of media. As this paper posits, knowledge that is inherently hard to verbalize makes a good use case for educational software. Software that models systems is particularly good at teaching computational thinking, and excels at teaching programming, if correctly applied. It enhances acquisition of skills like empirical validation, technical intuition etc.

# Conclusion

When teaching programming concepts, the traditional approach to training using text is much less effective because the student is hindered by his lack of knowledge of: the relation between hardware and software, programming languages, basic constructs (algorithms), core paradigms etc. With a traditional approach, before a student can learn complex abstract concepts, he must learn a programming language and how to write a simple program in that language. The use of specialized software allows for teaching those concepts to students without any prior knowledge, in parallel to other established methods.

Interactivity is one of the most important properties of computer software. It enables software to react to the actions of the user in ways that allow the user to gain experience and knowledge non-linguistically. Each interaction can be viewed as a self-contained experiment: the user thinks of a desirable outcome, tries an action, looks at the reaction, evaluates the outcome and repeats the loop if necessary. Coincidentally this mirrors thought processes that occur when completing programming tasks. Contemplating an idea, implementing it in code, launching it on a computer, the computer instantly reacting to it. If it reacts in an unexpected way it is seldom not a teaching moment, it enables learning from expertise [^albano]. The user learns something new about the programming language being used, about the way the computer processes information, or about his/her thought process. These characteristic properties of computer software could be harnessed for educational purposes.

Software engineering is an applied science. It requires expertise in multiple domains. It follows then that this expertise must be accrued using applied methodologies. “Expertise is an ability acquired mostly by experience” [^albano]. However, it is worth noting that this effect is not uniform with learners across all levels of experience. “When assessing which agent, either the instructor or the learner, was most effective, we observed mixed results in the literature. However, the expertise reversal effect may help predict the direction of these effects: novice students may learn better under instructor-managed conditions, whereas more expert students may learn more under learner-managed conditions” [^castro].

Software has the means to provide education with the tools required for enabling a richer learning experience, circumventing traditional text-heavy forms of teaching, providing more effective methods of learning concepts that are essential for developing computational thinking, that at the same time are hard to verbalize. As it was demonstrated above, code comprehension does not involve the language processing areas of the brain in any significant way. However, it remains to be seen how the act of designing and writing code activates the same areas of the brain, or whether it relies on them at all. It is also not clear to what extent the proposed new forms of teaching would be more effective as compared to the traditional forms. In any case this paper’s research cannot be considered conclusive. There is still the need to accumulate empirical proof to quantify the assumed positive effects of non-linguistic learning, but that would have to be the subject of a future study.

[^1]: [Zachademics](https://www.zachtronics.com/zachademics/)
[^2]: [Video Games and the Future of Education](https://www.youtube.com/watch?v=qWFScmtiC44)
[^3]: [Star Code Galaxy](https://starcodegalaxy.com/)
[^4]: [Rethinking Visual Programming](https://www.youtube.com/watch?v=Ps3mBPcjySE)
[^5]: [Learn to Code FROM ZERO with Godot, the Free Game Engine](https://www.kickstarter.com/projects/gdquest/learn-to-code-from-zero-with-godot-the-free-game-engine)
[^6]: “**You Can Grow Your Intelligence**”, *Brainology Curriculum Guide for Teachers, Mindset Works, 2014*
[^petersen]: C. I. Petersen, P. Baepler, A. J. Beitz, and J. Walker, “**The Tyranny of Content: “Content Coverage” as a Barrier to Evidence-Based Teaching Approaches and Ways to Overcome It**”, *CBE life sciences education, 2020* 
[^olsson]: M. Olsson, and P. Mozelius, “**Learning to Program by Playing Learning Games**”, *European Conference on Games Based Learning, 2017* 
[^mayer]: R. Mayer, and L. Fiorella, “**Principles for reducing extraneous processing in multimedia learning: Coherence, signaling, redundancy, spatial contiguity, and temporal contiguity principles**”, *Cambridge Handbook of Multimedia Learning, pp.279-315, 2014* 
[^ds19]: **Developer Survey 2019: Open Source Runtime Pains**, *ActiveState, 2019* 
[^tl19]: “**How Much Time Do Developers Spend Actually Writing Code?**”, *Tidelift, The New Stack, 2019* 
[^albano]: G. Albano, and F. Formato, “**E-learning from Expertize: a Computational Approach to a non-textual Culture of Learning**”, *Advanced Learning Technologies Conference, 2001*
[^liu]: Y.-F. Liu, J. Kim, C. Wilson, and M. Bedny, “**Computer code comprehension shares neural resources with formal logical inference in the fronto-parietal network**”, *eLife, 2020*
[^ivanova]: A. Ivanova, S. Srikant, Y. Sueoka, H. H. Kean, R. Dhamala, U.-M. O’Reilly, M. U. Bers, and E. Fedorenko, “**Comprehension of computer code relies primarily on domain-general executive brain regions**”, *eLife, 2020*
[^siegmund]: J. Siegmund, C. Kastner, S. Apel, C. Parnin, A. Bethmann, T. Leich, G. Saake, and A. Brechmann, “**Understanding Understanding Source Code with Functional Magnetic Resonance Imaging**”, *ICSE, 2014*
[^vygotsky]: L. Vygotsky, “**Thinking and Speech**”, *State Socio-economic Publishing, Moscow, Leningrad, 1934, p. 88 (in Russian)*
[^kornilov]: Y. Kornilov, and I. Vladimirov, “**Instrumental experience as component of the experience of practical change**”, *Yaroslav Psychology Herald, ed. 16, RPO, Moscow, Yaroslavl, 2005, pp. 21-28 (in Russian)*
[^liszkowski]: U. Liszkowski, “**Three Lines in the Emergence of Prelinguistic Communication and Social Cognition**”, *Journal of Cognitive Education and Psychology, vol. 10, no. 1, Springer Publishing Company, 2011, pp. 32-43*
[^wing14]: J. M. Wing, “**Computational Thinking Benefits Society**”, *Social Issues in Computing, New York Academic Press, 2014*
[^wing06]: J. M. Wing, “**Computational Thinking**”, *Communications of the ACM, vol. 49, no. 3, 2006, pp. 33-35*
[^lamprou]: A. Lamprou, and A. Repenning, “**Computational Thinking [does not equal] Programming**”, *Swissinformatics Magazine, 2017*
[^oby]: E. R. Oby, M. D. Golub, J. A. Hennig, A. D. Degenhart, E. C. Tyler-Kabara, B. M. Yu, S. M. Chase, and A. P. Batista, “**New neural activity patterns emerge with long-term learning**”, *PNAS, 2019*
[^shibli]: D. Shibli, and R. West, “**Cognitive load theory and its application in the classroom**”, *Impact Journal of the Chartered College of Teaching, Making Learning Stick: Open Access Cognitive Science, 2018*
[^thees]: M. Thees, S. Kapp, M. P. Strzys, P. Lukiwicz, J. Kuhn, and F. Beil, “**Effects of augmented reality on learning and cognitive load in university physics laboratory courses**”, *Computers in Human Behavior, 2020*
[^mccrudden]: M. McCrudden, and D. N. Rapp, “**How Visual Displays Affect Cognitive Processing**”, *Educational Psychology Review, 2017*
[^villareale]: J. Villareale, C. F. Biemer, M. S. El-Nasr, and J. Zhu, “**Reflection in Game-Based Learning: A Survey of Programming Games**”, *preprint, 2020*
[^vernon]: M. D. Vernon, “**Cognitive Inference in Perceptual Activity**”, *British Journal of Psychology, vol. 48, no. 1, 1957, pp. 35-47*
[^huizinga]: J. Huizinga, “**Homo Ludens**”, *Progress, 1992, pp. 21-45 (in Russian)*
[^castro]: J. C. Castro-Alonso, B. B. de Koning, L. Fiorella, and F. Paas, “**Five Strategies for Optimizing Instructional Materials: Instructor- and Learner-Managed Cognitive Load**”, *Educational Psychology Review, 2021*